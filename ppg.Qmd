---
title: "PPG"
format:
  gfm:
    toc: false
    wrap: none
params:
  tax_level: "species"
execute: 
  echo: false
  message: false
  warning: false
---

```{r}
#| label: setup
source(here::here("R/packages.R"))
source(here::here("R/functions.R"))
library(glue)
library(tidyverse)
library(assertr)
library(taxlist)
library(taxnames)
conflicted::conflict_prefer("filter", "dplyr")

tar_load(c(ppg, families_in_phy_order), store = here::here("_targets"))
```

```{r}
#| label: ppg-treatment
#| results: asis

# Specify all higher taxonomic levels
higher_tax_levels_all <- c("class", "subclass", "order", "suborder", "family", "subfamily", "tribe", "subtribe", "genus")

# Format PPG data for printing out
ppg_print <-
  ppg |>
  # Only keeping higher, accepted taxa
  filter(taxonRank %in% higher_tax_levels_all) |>
  filter(taxonomicStatus == "accepted") |>
  # TODO fix these in Rhakhis
  # Remove bad taxa
  filter(
    taxonID != "wfo-4000030830", # Polystichopsis (J.Sm.) Holttum, PPG I has Polystichopsis (J.Sm.) C.Chr. nolint
    taxonID != "wfo-1000070090" # Todea Bernh., PPG I has Todea Willd. ex Bernh.
  )

# Identify higher taxonomic levels actually used
higher_tax_levels_used <- higher_tax_levels_all[higher_tax_levels_all %in% ppg_print$taxonRank]

# Set priorities for sorting by rank, check that all names are in data

# - class
priority_class <- c(
  "Lycopodiopsida",
  "Polypodiopsida"
)

class_check <- ppg_print |>
  filter(taxonRank == "class") |>
  assert(in_set(priority_class), scientificName, success_fun = success_logical)

# - subclass
priority_subclass <- c(
  "Equisetidae",
  "Ophioglossidae",
  "Marattiidae",
  "Polypodiidae"
)

subclass_check <- ppg_print |>
  filter(taxonRank == "subclass") |>
  assert(in_set(priority_subclass), scientificName, success_fun = success_logical)

# - order
priority_order <- c(
  # (Lycopodiopsida)
  "Lycopodiales",
  "Isoetales",
  "Selaginellales",
  # (Equisetidae)
  "Equisetales",
  # (Ophioglossidae)
  "Psilotales",
  "Ophioglossales",
  # (Marattiidae)
  "Marattiales",
  # (Polypodiidae)
  "Osmundales",
  "Hymenophyllales",
  "Gleicheniales",
  "Schizaeales",
  "Salviniales",
  "Cyatheales",
  "Polypodiales"
)

order_check <- ppg_print |>
  filter(taxonRank == "order") |>
  assert(in_set(priority_order), scientificName, success_fun = success_logical)

# TODO: Add suborder

# - family
priority_family <- c(
  "Lycopodiaceae",
  "Isoetaceae",
  "Selaginellaceae",
  rev(families_in_phy_order))

family_check <- ppg_print |>
  filter(taxonRank == "family") |>
  assert(in_set(priority_family), scientificName, success_fun = success_logical)

# Compile all priorities
priority_sort <- c(
  priority_class,
  priority_subclass,
  priority_order,
  priority_family
)

ppg_tl <- ppg_print |>
  dplyr::select(
    TaxonConceptID = taxonID,
    TaxonUsageID = taxonID,
    TaxonName = scientificName,
    AuthorName = scientificNameAuthorship,
    Level = taxonRank,
    Parent = parentNameUsageID
  ) |>
  mutate(AcceptedName = TRUE) |>
  as.data.frame() |>
  df2taxlist(levels = rev(higher_tax_levels_used))

# Format headers (indents) for each taxonomic level
indent_df <-
  tibble(level = rev(levels(ppg_tl))) |>
  mutate(
    indent_num = 0:(length(levels(ppg_tl)) - 1)
  ) |>
  rowwise() |>
  mutate(
    indent = paste0(rep("#", indent_num), collapse = ""),
    indent = paste0(indent, "##", collapse = "")
  ) |>
  ungroup() |>
  # The lowest taxonomic level should not have an indent (header)
  mutate(
    indent = case_when(
      level == first(levels(ppg_tl)) ~ "",
    .default = indent
  )) |>
  select(level, indent)

# Print out as text
ppg_tl |>
  sort_taxa(priority = priority_sort) |>
  indented_list(indent = "", print = FALSE) |>
  as_tibble() |>
  select(-indent) |>
  janitor::clean_names() |>
  left_join(
    indent_df, by = "level",
    relationship = "many-to-one"
  ) |>
  mutate(
    formatted_name = case_when(
      level == "genus" ~ glue::glue("*{taxon_name}* {author_name}"),
      level != "genus" ~ glue::glue(
        "{indent} {str_to_sentence(level)} **{taxon_name}** {author_name}"
      ),
      .default = formatted_name
    ),
    formatted_name = as.character(formatted_name)
  ) |>
  pull(formatted_name) |>
  cat(sep = "\n\n")
```
